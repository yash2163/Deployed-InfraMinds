InfraMinds — The Self-Reasoning Cloud Architect
Project Summary
InfraMinds is an autonomous AI system that designs, validates, and stress-tests cloud infrastructure architectures from high-level human intent. Instead of producing static diagrams or Terraform templates, the agent maintains a Living State Graph of the infrastructure, continuously simulates changes, detects violations, self-corrects designs, and outputs verified Infrastructure-as-Code.
It demonstrates long-horizon reasoning, tool-using autonomy, persistent decision memory, and causal graph simulation, directly aligning with the Gemini 3 “Action Era” vision.

Problem
Designing cloud infrastructure is:
	•	Ambiguous at requirement stage
	•	Error-prone during translation to IaC
	•	Hard to verify for security and reliability
	•	Risky to change once deployed
Existing tools:
	•	Either static diagram generators
	•	Or chat-based Terraform generators
	•	With no persistent system understanding
	•	No causal impact simulation
There is no autonomous system that:
	•	Maintains a living infra state
	•	Reasons over dependency graphs
	•	Self-corrects designs
	•	Simulates consequences of changes

Solution
InfraMinds acts as a Graph-Reasoning Architect Agent.
From a natural-language goal, it:
	•	Extracts infrastructure intent
	•	Generates Terraform design
	•	Builds a dependency graph from the Terraform plan
	•	Runs policy and reliability reasoning queries
	•	Self-corrects violations
	•	Simulates “what-if” changes through graph traversal
	•	Outputs verified IaC and architecture visualization
All without touching real cloud resources.

Core Innovation
Living State Graph
The system’s central memory is a continuously updated graph:
	•	Nodes → infrastructure resources
	•	Edges → dependency + traffic + trust relationships
	•	Node metadata → configuration attributes
This graph becomes:
	•	The agent’s long-term memory
	•	The reasoning substrate
	•	The simulation engine
Every design iteration updates the graph. All decisions reference the graph state.

Functional Requirements
1. Intent Understanding
	•	Input: Natural language goal
	•	Output: Structured infra requirements
	•	Example extraction:
	•	HA required
	•	Containerized workload
	•	Public web endpoint
	•	Security best practices
2. Autonomous Architecture Drafting
	•	Gemini writes Terraform modules:
	•	VPC
	•	Subnets (multi-AZ)
	•	Load Balancer
	•	ECS/Fargate Service
	•	Database
	•	IAM roles
	•	Security groups
3. Terraform Plan Execution
	•	Runs terraform plan
	•	Produces JSON plan output
	•	No real cloud provisioning
4. Graph Construction
	•	Parse Terraform plan JSON
	•	Build graph:
	•	Nodes = resources
	•	Edges = depends_on + network reachability + identity trust
5. Graph Visualization
	•	React + D3 / ReactFlow live rendering
	•	Nodes appear as agent designs resources
	•	Edge coloring for dependency vs traffic
6. Policy & Reliability Reasoning
Graph queries detect violations:
Security:
	•	Public SSH/RDP open to world
	•	Database publicly reachable
	•	Over-permissive IAM
Reliability:
	•	Single-AZ critical services
	•	Missing health checks
	•	Missing load balancer
Architecture consistency:
	•	Service not connected to ALB
	•	No NAT for private subnet egress
7. Self-Correction Loop
If violations found:
	•	Gemini edits Terraform
	•	Re-runs plan
	•	Graph rebuilds
	•	Queries re-executed
	•	Loop until all checks pass
8. Decision Log
Readable explanation stream:
	•	“Multi-AZ topology applied for HA”
	•	“Public SSH rule rejected”
	•	“Database isolated in private subnet”
	•	“All validation checks passed”
(No chain-of-thought exposure.)
9. Time-Travel Simulation (Differentiator)
User selects a change:
	•	“Remove NAT Gateway”
	•	“Move DB to public subnet”
Agent:
	•	Runs graph traversal
	•	Highlights affected nodes
	•	Outputs predicted failure chain:
	•	“ECS tasks lose outbound access → container pulls fail”
This demonstrates causal reasoning.
10. Verification Simulation
Local containerized test:
	•	Dummy web service container
	•	Simulated ALB routing
	•	Curl health check = 200 OK
Shows end-to-end verification behavior.
11. Final Output
	•	Terraform bundle download
	•	Architecture graph
	•	Compliance report
	•	Decision log

Non-Functional Requirements
	•	No real cloud calls
	•	Deterministic demo
	•	Fast iteration loops
	•	Visual judge-friendly UI
	•	Fully local reproducibility

System Architecture
[ Web UI ]
   |
   | Intent
   v
[ Gemini Orchestrator ]
   |
   | Terraform Draft
   v
[ Terraform CLI ]
   |
   | Plan JSON
   v
[ Graph Builder ]
   |
   v
[ Graph DB / In-Memory Graph ]
   |        |
   |        +--> [Graph Visualizer]
   |
   +--> [Policy Engine]
   |
   +--> [Simulation Engine]
   |
   +--> [Decision Log]

Technology Stack
Frontend:
	•	React + Next.js
	•	ReactFlow or D3.js
	•	Monaco editor (Terraform view)
Backend:
	•	Node.js / Python FastAPI
	•	Gemini 3 API Orchestrator
	•	Terraform CLI (local)
	•	Graph engine:
	•	NetworkX (Python) or Neo4j
	•	Policy queries:
	•	Cypher or custom graph rules
Container Runtime:
	•	Docker for verification simulation

Gemini 3 Usage
	•	Long-horizon multi-step planning
	•	Tool invocation (Terraform, Graph queries)
	•	Persistent decision context
	•	Autonomous correction loops
	•	Natural-language decision reporting

Demo Flow (3–4 minutes)
	•	User enters request
	•	Graph begins forming live
	•	Violation appears (open SSH)
	•	Agent self-fixes
	•	Graph turns compliant
	•	User runs time-travel change
	•	Impact highlighted
	•	Verification test passes
	•	Download Terraform pack

Why This Wins
	•	Not a chatbot
	•	Not RAG
	•	Not static generation
	•	Shows real autonomy
	•	Shows real reasoning
	•	Shows persistent world model
	•	Visually impressive
	•	Technically deep
	•	Directly aligned with Gemini 3 narrative

Scope Fit for 15 Days
Week 1:
	•	Terraform templates
	•	Graph builder
	•	Policy rules
	•	Gemini orchestration
Week 2:
	•	UI
	•	Visualization
	•	Simulation
	•	Demo polish
Comfortable margin.

Possible Optional Enhancements
Only if time remains:
	•	Cost estimation node attributes
	•	Policy rule editor UI
	•	Export to draw.io
Not required to win.

Final Positioning Statement
InfraMinds is not an AI that writes Terraform. It is an AI that understands infrastructure as a living system, reasons over its state, corrects itself, and predicts consequences before changes occur.
That sentence alone matches the hackathon thesis.

