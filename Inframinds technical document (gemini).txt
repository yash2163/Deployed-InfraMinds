ðŸ—ï¸ InfraMinds: The Graph-Reasoning Cloud Architect
Project Status: Detailed Design Specification Hackathon Track: ðŸ§  The Marathon Agent (Primary) | â˜¯ï¸ Vibe Engineering (Secondary)

1. Executive Summary
InfraMinds is an autonomous infrastructure agent that moves beyond "Text-to-Code." Instead of blindly generating Terraform scripts, it builds a Living State Graph of the desired architecture. It uses Gemini 3â€™s reasoning capabilities to simulate changes, verify security constraints, and predict "blast radius" outages before any code is deployed. It transforms the "Black Box" of AI coding into a transparent, visual, and interactive "Glass Box."
Core Differentiator: The Blast Radius Simulator (Time-Travel). The user can propose a destructive change (e.g., "Delete NAT Gateway"), and the agent visually highlights the cascading failure paths (e.g., "Database subnet loses internet access") without touching real infrastructure.

2. Core Functionalities
A. Intent Parsing & Constraint Extraction
	â€¢	Input: Vague natural language (e.g., "I need a scalable API for a fintech app").
	â€¢	Function: Gemini 3 decomposes this into strict technical invariants.
	â€¢	Inferred Constraints: Fintech = Private Subnets, Encryption Enabled, WAF. Scalable = ALB, Auto-Scaling Group.
	â€¢	Output: A JSON "Blueprint" object, not code yet.
B. The Living State Graph (The UI Heart)
	â€¢	Function: Renders the infrastructure as an interactive node-link diagram.
	â€¢	Interaction: Users can click nodes to see configuration details.
	â€¢	Visual Feedback: Nodes change color based on state (Grey = Planned, Yellow = Verifying, Green = Deployed, Red = Error/Risk).
C. The "Blast Radius" Simulator (Killer Feature)
	â€¢	Trigger: User selects a node and asks "What if I remove this?" or "What if I open port 22?"
	â€¢	Logic: The backend traverses the graph dependencies.
	â€¢	Gemini Reasoning: The model analyzes the downstream impact on specific services (e.g., "Removing this Security Group rule breaks the connection between API and DB").
	â€¢	Output: A visual "Kill Chain" highlighting the path of failure on the graph.
D. Autonomous Self-Correction Loop
	â€¢	Trigger: A constraint violation (e.g., Security Group allows 0.0.0.0/0).
	â€¢	Logic:
	â€¢	Graph Query detects the insecure edge.
	â€¢	Gemini generates a fix (Terraform code update).
	â€¢	Graph is re-generated.
	â€¢	Loop continues until Violations == 0.
E. Sandbox Verification
	â€¢	Engine: LocalStack (running in Docker).
	â€¢	Process: Before giving the user the download link, the agent spins up the key resources locally and runs a curl or netcat test to prove the network routing actually works.

3. Technical Architecture
High-Level Stack
	â€¢	Frontend: React + React Flow (Visualization) + Tailwind CSS.
	â€¢	Backend: Python (FastAPI) or Node.js.
	â€¢	AI Engine: Google Gemini 3 Pro (via Vertex AI or AI Studio).
	â€¢	Graph Engine: NetworkX (Python library) for logic / dependency traversal.
	â€¢	Infrastructure: Terraform (HCL), LocalStack (Docker).
Data Flow Diagram
	â€¢	User Prompt â†’ Gemini 3 â†’ JSON Blueprint.
	â€¢	JSON Blueprint â†’ NetworkX Graph (Backend) â†’ React Flow (Frontend UI).
	â€¢	Graph Logic Check (NetworkX) â†’ If Fail â†’ Self-Correction Loop.
	â€¢	Graph Logic Check â†’ If Pass â†’ Terraform Code Gen.
	â€¢	Terraform Code â†’ LocalStack Deploy â†’ Verification Test.
	â€¢	Verification Result â†’ Update UI (Green Checkmarks).

4. Implementation Details (The "How-To")
Phase 1: The Graph Data Structure (Crucial)
Don't parse raw Terraform text. It's too hard. Have Gemini generate an intermediate JSON representation first.
The Prompt Schema (Gemini Output):
JSON
{
  "resources": [
    { "id": "vpc_1", "type": "aws_vpc", "properties": { "cidr": "10.0.0.0/16" } },
    { "id": "public_subnet", "type": "aws_subnet", "depends_on": ["vpc_1"] },
    { "id": "web_server", "type": "aws_instance", "depends_on": ["public_subnet"] }
  ],
  "edges": [
    { "source": "vpc_1", "target": "public_subnet", "relation": "contains" },
    { "source": "public_subnet", "target": "web_server", "relation": "hosts" }
  ]
}
	â€¢	Why: This JSON is easy to feed into React Flow and NetworkX.
	â€¢	Step 2: Generate the actual .tf files from this JSON (or ask Gemini to do the translation as a final step).
Phase 2: The "Blast Radius" Logic
You don't need complex simulation physics. Use Graph Traversal + LLM Context.
	â€¢	Algorithm:
	â€¢	User deletes Node A.
	â€¢	NetworkX finds all descendants of Node A.
	â€¢	Prompt to Gemini: "The user is deleting Node A (NAT Gateway). The following nodes depend on it: [Node B, Node C]. Based on AWS architecture principles, describe exactly what will fail and why."
	â€¢	UI: Highlight Node B and C in red. Display Gemini's text response.

5. What You Missed (The "Critical Friend" Additions)
A. The "Cost" Overlay (Easy Win)
	â€¢	Idea: Since you already know the resource types (e.g., t3.medium, ALB), have a simple lookup table (or ask Gemini) to estimate the monthly cost.
	â€¢	UI: Show a live price tag in the corner of the graph: "$45.00 / month."
	â€¢	Why: Judges love "Business Value."
B. "Thought Signature" Console
	â€¢	Idea: You need a specific UI panel that logs the Agent's Internal Monologue.
	â€¢	Format:
	â€¢	[PLANNING] Analyzing VPC requirements...
	â€¢	[CRITIQUE] Wait, single AZ is risky. Switching to Multi-AZ.
	â€¢	[VERIFYING] checking port 22...
	â€¢	Why: This proves it's the "Action Era" (Thinking Levels) and not just a script.
C. Limited Scope (The Safety Rail)
	â€¢	Constraint: Do not try to support all AWS resources.
	â€¢	Hard Limit: Support ONLY:
	â€¢	VPC, Subnets, Internet Gateway, NAT Gateway.
	â€¢	EC2, Security Groups.
	â€¢	RDS (Postgres).
	â€¢	ALB (Load Balancer).
	â€¢	Why: If you try to support Lambda, S3, DynamoDB, etc., you will drown in edge cases. A perfect demo of a small scope wins; a broken demo of a large scope loses.

6. Hackathon Roadmap (48 Hours)
	â€¢	Hour 0-4: Setup React Flow and FastAPI. Get a hardcoded graph to render.
	â€¢	Hour 4-12: Build the Gemini Prompt pipeline (Prompt -> JSON -> Graph).
	â€¢	Hour 12-20: Implement the "Time Travel" (Delete Node -> Red Graph) logic. (Key Milestone)
	â€¢	Hour 20-30: Build the Terraform generation and LocalStack integration.
	â€¢	Hour 30-40: Polish the UI (Thought Console, Animations).
	â€¢	Hour 40-48: Record the demo video. Focus 100% on the narrative.
Ready to build? Start by initializing the React Flow project. That visual is your anchor.

